package org.softlang.megal.content

import org.softlang.util.fwasp
import kotlin.reflect.KClass

/**
 * Arbitrary, adaptable content. Methods for obtaining content are:
 * [generator] to obtain a generating function, [get] to obtain an instance,
 * [into] to run a block with an instance.
 * @property providers Set of all root content providers.
 * @property adapters Set of all content adaptions.
 */
class Content(
        val providers: Set<Provider<*>>,
        val adapters: Set<Adapter<*, *>>) {
    /**
     * Direct content provision as map.
     */
    private val contentProvisions by lazy {
        providers.associate {
            (it to it.type) to listOf<Adapter<*, *>>()
        }
    }

    /**
     * Indirect content provision as map.
     */
    private val contentAdaptions by lazy {
        fwasp(providers, adapters,
                Provider<*>::type,
                Adapter<*, *>::src,
                Adapter<*, *>::dst)
    }

    /**
     * All content paths.
     */
    private val contentPaths by lazy {
        contentProvisions + contentAdaptions
    }

    /**
     * Shortest content paths.
     */
    private val contentGenerators by lazy {
        // From content paths find all reachable types
        contentPaths
                .keys
                .map(Pair<*, Type<*>>::second)
                .associate { t ->
                    // Find shortest generating path, regardless of the provider
                    val (k, v) = contentPaths
                            .filterKeys { it.second == t }
                            .minBy { it.value.size }!!

                    // Associated the type to the invocation chain
                    k.second to v.fold(k.first.get) { gen, adapter ->
                        {
                            // Suppress warnings here as construction of the
                            // graph is type safe
                            @Suppress("UNCHECKED_CAST")
                            (adapter.transformation as (Any) -> Any)(gen())
                        }
                    }
                }
    }

    /**
     * Manifests all provided representations, but not the adapted
     * representations.
     */
    val manifested get() = providers
            .associate { it.type to it.get() }

    /**
     * Lists all available types in this content.
     */
    val availableTypes get() = contentPaths
            .keys
            .map(Pair<*, Type<*>>::second)
            .toSet()

    /**
     * List of all potentially available types in this content.
     */
    val potentialTypes get() = providers.map { it.type } union
            adapters.map { it.dst }

    /**
     * Returns the generator function for the given type.
     */
    fun <T : Any> generator(type: Type<T>): () -> T {
        @Suppress("UNCHECKED_CAST")
        return contentGenerators.getValue(type) as () -> T
    }

    /**
     * Returns the generator function for the given type.
     */
    inline fun <reified T : Any> generator(mime: Mime) =
            generator(Type(mime, T::class))

    /**
     * Returns the generator function for the given type.
     */
    inline fun <reified T : Any> generator(mime: String) =
            generator(Type(parseMime(mime), T::class))

    /**
     * Gets a value generated by the given type's generator.
     */
    operator fun <T : Any> get(type: Type<T>): T =
            generator(type)()

    /**
     * Gets a value generated by the given type's generator.
     */
    inline operator fun <reified T : Any> get(mime: Mime) =
            get(Type(mime, T::class))

    /**
     * Gets a value generated by the given type's generator.
     */
    inline operator fun <reified T : Any> get(mime: String) =
            get(Type(parseMime(mime), T::class))

    /**
     * Runs the block with the value generated by the given type's generator.
     */
    fun <T : Any, U> into(type: Type<T>, block: (T) -> U) =
            block(get(type))

    /**
     * Runs the block with the value generated by the given type's generator.
     */
    inline fun <reified T : Any, U> into(mime: Mime, block: (T) -> U) =
            block(get(Type(mime, T::class)))

    /**
     * Runs the block with the value generated by the given type's generator.
     */
    inline fun <reified T : Any, U> into(mime: String, block: (T) -> U) =
            block(get(Type(parseMime(mime), T::class)))

    override fun hashCode() =
            manifested.hashCode()

    override fun equals(other: Any?) =
            other is Content && manifested == other.manifested

    override fun toString() =
            manifested.toString()
}

/**
 * Unifies the contents, composing both providers and adapters set-wise.
 */
infix fun Content.union(other: Content) = Content(
        providers union other.providers,
        adapters union other.adapters)

/**
 * Implements a singleton content by a provider.
 */
infix fun <T : Any> Type<T>.by(get: () -> T) =
        Content(setOf(Provider(this, get)), emptySet())

/**
 * Implements a singleton content by a provider using the reified type argument.
 */
inline infix fun <reified T : Any> Mime.by(noinline get: () -> T) =
        Type(this, T::class) by get

/**
 * Implements a singleton content by a provider using the reified type argument.
 */
inline infix fun <reified T : Any> String.by(noinline get: () -> T) =
        parseMime(this) by get


fun printByteArray(ba: ByteArray) {
    println(ba.joinToString { "$it" })
}

fun main(args: Array<String>) {
    // Configure a data source
    val cs = config<String>("text/plain") {
        by { "Hallo" }
    }
    val cs2 = config<String>("text/plain") {
        by { "Hallo" }
    }

    // Check hash and equality
    println(cs.hashCode())
    println(cs2.hashCode())
    println(cs == cs2)

    // Configure some transformation functions
    val tf1 = config<String>("text/plain") {
        to("application/octet-stream") { it.toByteArray() }

        to("text/html") { "<html><body>$it</body></html>" }
    }

    // Configure second set for testing
    val tf2 = config<String>("application/xml") {
        to("application/json") {
            "... unused ..."
        }
    }

    // Unify
    val cc = cs union tf1 union tf2

    // List potential and available types
    println(cc.potentialTypes)
    println(cc.availableTypes)

    // Pass into block
    cc.into("text/plain") { s: String -> println(s) }

    // Infer by call site
    printByteArray(cc["application/octet-stream"])
}